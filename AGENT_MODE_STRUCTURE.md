# Agent Mode: полная структура работы

Этот документ описывает полный цикл работы режима `agent` в проекте **Local RAG Assistant**: от загрузки манифестов до ответа модели в чате.

## 1. Что такое режим `agent`

Режим `agent` — это режим чата, в котором система отвечает в роли выбранного агента (например, `copywriter`, `designer`, `chemist`) вместо строгого RAG или обычного model-режима.

Ключевая идея:
- роли агентов описаны в манифестах;
- backend выбирает конкретного агента;
- в LLM отправляется специальный системный промпт с «карточкой агента»;
- ответ возвращается в UI как обычный/стриминговый ответ чата.

---

## 2. Где хранится конфигурация агентов

Основной источник — `agent/registry.json`.

Для каждого агента задаются:
- `id` — технический идентификатор;
- `name` — отображаемое имя;
- `description` — роль агента;
- `version` — версия манифеста;
- `requires` — зависимости/условия;
- `tools` — логические инструменты роли;
- `notebook_modes` — режимы, где агент доступен (обычно `agent`);
- `provider` — LLM-провайдер (в текущем сценарии `ollama`);
- `model` — модель, рекомендуемая для агента.

---

## 3. Сервис резолва агентов (backend)

Файл: `apps/api/services/agent_registry.py`.

### 3.1. Поиск директории `agent/`

Сервис ищет папку агентов в устойчивом порядке:
1. переменная окружения `AGENTS_DIR`;
2. `<cwd>/agent`;
3. module-relative fallback-пути.

Это сделано, чтобы проект одинаково работал в разных окружениях (Windows/Linux, запуск из IDE, скриптов, контейнеров).

### 3.2. Нормализация манифестов

Каждый манифест проходит через `normalize_agent_manifest(...)`, который:
- приводит поля к строкам/спискам;
- добавляет дефолты (`version`, `notebook_modes`, `provider`, `model`);
- фильтрует пустые значения.

### 3.3. Порядок загрузки

`list_agents()` использует fallback:
1. `load_agents_from_registry()` из `registry.json`;
2. если реестр пуст/невалиден — `discover_agents_from_folders()` из `agent/*/manifest.json`.

### 3.4. Выбор конкретного агента

`resolve_agent(agent_id)`:
- ищет агента по `id`;
- если `id` не найден/пустой — возвращает первого доступного агента;
- если агентов нет — `None`.

---

## 4. API для фронтенда

Файл: `apps/api/routers/agents.py`.

Поддерживаются оба endpoint'а:
- `GET /api/agents`
- `GET /agents`

Оба маршрута используют один и тот же сервисный слой (`agent_registry`) и возвращают список нормализованных манифестов.

Зачем два пути:
- совместимость со старыми фронтенд/бекенд сборками;
- безопасная миграция без «пустого списка агентов» в UI.

---

## 5. Поток выбора агента на фронтенде

### 5.1. Загрузка агентов

Файл: `apps/web/lib/api.ts`, метод `listAgents()`.

Порядок попыток:
1. запрос `GET /api/agents`;
2. если пусто/ошибка — `GET /agents`;
3. если снова пусто/ошибка — локальный fallback `DEFAULT_AGENT_MANIFESTS` (3 встроенных агента).

Итог: dropdown не должен оставаться пустым даже при временных проблемах backend.

### 5.2. Синхронизация выбранного агента

Файл: `apps/web/src/stores/agentStore.ts`.

- выбранный `agentId` хранится в store + localStorage;
- при обновлении списка выполняется `syncSelectedAgentWithManifest(...)`;
- если сохранённый `agentId` больше невалиден — берётся первый агент из списка.

### 5.3. Передача в страницу ноутбука

Файл: `apps/web/app/notebooks/[id]/page.tsx`.

- вычисляется `effectiveAgentId` (текущий выбранный или первый доступный);
- при отправке запроса в режиме `agent` в stream передаётся именно `effectiveAgentId`.

### 5.4. UI-селект агента

Файл: `apps/web/components/ChatPanel.tsx`.

- в верхней панели есть режимы чата (`rag/model/agent`);
- если выбран `agent`, рядом показывается dropdown выбора конкретного агента;
- если список пуст, показываются состояния: загрузка / ошибка / нет доступных.

---

## 6. Как backend обрабатывает `agent`-сообщение

Файл: `apps/api/routers/chat.py`.

### 6.1. Общие шаги

1. Получаем `agent_id` из запроса.
2. Вызываем `resolve_agent(...)`.
3. Формируем карточку агента `_agent_context(...)`.
4. Готовим provider/model/base_url с fallback-логикой.
5. Вызываем LLM слой:
   - `generate_model_answer(...)` для обычного ответа;
   - `stream_model_answer(...)` для стрима.

### 6.2. Базовый URL провайдера

`_resolve_base_url(...)`:
- если `base_url` пришёл в запросе — используем его;
- иначе `OLLAMA_BASE_URL`;
- иначе дефолт `http://127.0.0.1:11434`.

### 6.3. Provider/Model

Приоритет в agent-режиме:
1. значения из runtime payload;
2. значения из выбранного манифеста агента (`provider`, `model`);
3. дефолты (`ollama`, пустая модель с валидацией в model layer).

---

## 7. Промпты для agent-режима

Файл: `apps/api/services/prompts.py`.

В `build_messages_for_mode(...)` есть отдельная ветка `chat_mode == "agent"`, где используется `_SYSTEM_AGENT_TEMPLATE`.

Системный промпт заставляет модель:
- отвечать в пределах роли;
- структурировать ответ (цель → действия → результат);
- задавать уточнения при неопределённости;
- не «размывать» ответ.

Карточка агента (`agent_context`) подставляется в этот шаблон.

---

## 8. Взаимодействие с LLM-провайдером

Файл: `apps/api/services/model_chat.py`.

### 8.1. Нестриминговый путь

`generate_model_answer(...)`:
- валидирует `provider/base_url/model`;
- формирует `messages` через `build_messages_for_mode(...)`;
- для `ollama` отправляет POST в `{base_url}/api/chat`;
- возвращает текст ответа или диагностическое сообщение об ошибке.

### 8.2. Стриминговый путь

`stream_model_answer(...)`:
- открывает streaming-запрос;
- парсит чанки/токены;
- прокидывает токены в SSE поток `chat_stream`;
- при ошибке поднимает `RuntimeError`, который роутер переводит в SSE `error`.

---

## 9. Мини-схема «от кнопки до ответа»

1. Пользователь выбирает режим **Agent** и агента в dropdown.
2. UI отправляет сообщение + `agentId`.
3. `chat.py` резолвит манифест агента.
4. Собирается `agent_context` и системный prompt agent-режима.
5. Вызывается Ollama (или совместимый provider, если задан).
6. Токены/ответ возвращаются в UI.
7. Сообщение сохраняется в истории ноутбука.

---

## 10. Диагностика проблем

### Симптом: "Нет доступных агентов"
Проверить:
1. что `agent/registry.json` существует и валиден;
2. что backend endpoint `/api/agents` возвращает непустой массив;
3. что backend запущен из ожидаемой директории (или задан `AGENTS_DIR`);
4. что фронтенд перезапущен после обновления.

### Симптом: backend логирует `Agents directory not found`
Значит не найден путь к папке `agent/`.
Решение:
- запускать backend из корня репозитория;
- либо явно задать `AGENTS_DIR=<абсолютный путь до repo>/agent`.

### Симптом: агент выбран, но ответ «не по роли»
Проверить:
1. какой `agentId` реально ушёл в запрос;
2. какой `model` у агента в манифесте;
3. не переопределяется ли `provider/model` runtime-настройками.

---

## 11. Практические рекомендации

- Храните манифесты агентов только в одном источнике (`agent/registry.json`) и версионируйте его в git.
- Для production/команды фиксируйте список моделей (`ollama pull ...`) заранее.
- Для стабильного деплоя задайте `AGENTS_DIR` и `OLLAMA_BASE_URL` в окружении.
- Не удаляйте fallback-маршрут `/agents`, пока не убедились, что все клиенты используют `/api/agents`.

